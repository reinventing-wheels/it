// tslint:disable:only-arrow-functions
import { unwrap, wrap, next } from '../util';
/** Calls a function for each value of an iterable. */
export function forEach(it, fn) {
    let i = 0;
    for (const value of it)
        fn(value, i++);
}
/** Reduces an iterable to a single value. */
export function reduce(it, fn, first) {
    let i = 0, acc = first;
    for (const value of it)
        acc = fn(acc, value, i++);
    return acc;
}
/** Filters values of an iterable. */
export function* filter(it, fn) {
    let i = 0;
    for (const value of it)
        if (fn(value, i++))
            yield value;
}
/** Maps values of an iterable. */
export function* map(it, fn) {
    let i = 0;
    for (const value of it)
        yield fn(value, i++);
}
/** Concatenates multiple iterables to a single one. */
export function* concat(...its) {
    for (const it of its)
        yield* it;
}
/** Repeatedly yields values from the same iterable. */
export function* repeat(it) {
    for (;;)
        yield* it;
}
/** Always yields the same value. */
export function* always(value) {
    for (;;)
        yield value;
}
/** Loops a generator function. */
export function* loop(fn) {
    for (let i = 0;;)
        yield* fn(i++);
}
/** Yields values generated by a function. */
export function* generate(fn) {
    for (let i = 0;;)
        yield fn(i++);
}
/** Yields a sequence of values derived from previous values. */
export function* sequence(fn, first) {
    for (let i = 0, value = first;; value = fn(value, i++))
        yield value;
}
/** Yields a sequence of monotonically increasing numbers. */
export function* range(start = 0, stop = Infinity, step = 1) {
    for (let number = start; number < stop; number += step)
        yield number;
}
/** Yields a sequence of matches. */
export function* match(input, regexp) {
    for (let match; match = regexp.exec(input);)
        yield match;
}
/** Takes some amount values from an iterable. */
export function* take(it, amount) {
    let i = 0;
    const itʹ = unwrap(it);
    const done = { done: true };
    yield* next(() => i++ < amount ? itʹ.next() : done);
}
/** Drops some amount values from an iterable. */
export function* drop(it, amount) {
    const itʹ = wrap(unwrap(it)); // always return the same iterator
    for (const _ of take(itʹ, amount))
        ; // noop
    yield* itʹ;
}
