import { unwrap, wrap, iter, done, value } from '../util';
/** Calls a function for each value of an iterable. */
export function forEach(it, fn) {
    let i = 0;
    for (const value of it)
        fn(value, i++);
}
/** Reduces an iterable to a single value. */
export function reduce(it, fn, first) {
    let i = 0, acc = first;
    for (const value of it)
        acc = fn(acc, value, i++);
    return acc;
}
/** Filters values of an iterable. */
export function* filter(it, fn) {
    let i = 0;
    for (const value of it)
        if (fn(value, i++))
            yield value;
}
/** Maps values of an iterable. */
export function* map(it, fn) {
    let i = 0;
    for (const value of it)
        yield fn(value, i++);
}
/** Concatenates multiple iterables to a single one. */
export function* concat(...its) {
    for (const it of its)
        yield* it;
}
/** Flattens an iterable. */
export function* flatten(it) {
    for (const value of it)
        yield* value;
}
/** Yields values from an iterable in cycle. */
export function* cycle(it) {
    for (;;)
        yield* it;
}
/** Repeatedly yields the same value. */
export function* repeat(value) {
    for (;;)
        yield value;
}
/** Loops a generator function. */
export function* loop(fn) {
    for (let i = 0;;)
        yield* fn(i++);
}
/** Yields values generated by a function. */
export function* generate(fn) {
    for (let i = 0;;)
        yield fn(i++);
}
/** Yields a sequence of values derived from previous values. */
export function* sequence(fn, first) {
    for (let i = 0, value = first;; value = fn(value, i++))
        yield value;
}
/** Yields a sequence of monotonically increasing numbers. */
export function* range(start = 0, stop = Infinity, step = 1) {
    for (let number = start; number < stop; number += step)
        yield number;
}
/** Yields a sequence of matches. */
export function* match(input, regexp) {
    for (let match; match = regexp.exec(input);)
        yield match;
}
/** Yields an iterable by chunks of specified size. */
export function* chunk(it, size) {
    for (let chunk; (chunk = [...take(it, size)]).length;)
        yield chunk;
}
/** Zips multiple iterables to a single one. */
export function* zip(...its) {
    const itsʹ = its.map(unwrap);
    yield* iter(() => {
        const rs = itsʹ.map(it => it.next());
        const r = rs.find(r => r.done) || value(rs.map(r => r.value));
        return r;
    });
}
/** Takes specified amount of values from an iterable. */
export function* take(it, amount) {
    let i = 0;
    const itʹ = unwrap(it);
    yield* iter(() => i++ < amount ? itʹ.next() : done());
}
/** Drops specified amount of values from an iterable. */
export function* drop(it, amount) {
    const itʹ = wrap(unwrap(it)); // always return the same iterator
    for (const _ of take(itʹ, amount))
        ; // noop
    yield* itʹ;
}
