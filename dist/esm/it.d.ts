import * as uncurried from './functions/uncurried';
import * as curried from './functions/curried';
export declare const it: <T>(it: Iterable<T>) => It<T>;
export declare class It<T> implements Iterable<T> {
    [Symbol.iterator]: () => Iterator<T>;
    static uncurried: typeof uncurried;
    static curried: typeof curried;
    /** Always yields the same value. */
    static always<T>(value: T): It<T>;
    /** Loops a generator function. */
    static loop<T>(fn: (index: number) => Iterable<T>): It<T>;
    /** Yields values generated by a function. */
    static generate<T>(fn: (index: number) => T): It<T>;
    /** Yields a sequence of values derived from previous values. */
    static sequence<T>(fn: (previous: T, index: number) => T, first: T): It<T>;
    /** Yields a sequence of monotonically increasing numbers. */
    static range(start?: number, stop?: number, step?: number): It<number>;
    /** Yields a sequence of matches. */
    static match(input: string, regexp: RegExp): It<RegExpExecArray>;
    constructor(it: Iterable<T>);
    /** Casts the iterable to other data structure. */
    cast<T>(fn: (it: this) => T): T;
    /** Calls a function for each value of the iterable. */
    forEach(fn: (value: T, index: number) => void): void;
    /** Reduces the iterable to a single value. */
    reduce<U>(fn: (previous: U, current: T, index: number) => U, first: U): U;
    /** Filters values of the iterable. */
    filter(fn: (value: T, index: number) => boolean): It<T>;
    /** Maps values of the iterable. */
    map<U>(fn: (value: T, index: number) => U): It<U>;
    /** Concatenates multiple iterables to a single one. */
    concat<U>(...its: Iterable<U>[]): It<T | U>;
    /** Repeatedly yields values from the iterable. */
    repeat(): It<T>;
    /** Takes some amount values from the iterable. */
    take(amount: number): It<T>;
    /** Drops some amount values from the iterable. */
    drop(amount: number): It<T>;
}
