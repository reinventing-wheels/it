"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
// tslint:disable:only-arrow-functions
const util_1 = require("../util");
/** Calls a function for each value of an iterable. */
function forEach(it, fn) {
    let i = 0;
    for (const value of it)
        fn(value, i++);
}
exports.forEach = forEach;
/** Reduces an iterable to a single value. */
function reduce(it, fn, first) {
    let i = 0, acc = first;
    for (const value of it)
        acc = fn(acc, value, i++);
    return acc;
}
exports.reduce = reduce;
/** Filters values of an iterable. */
function* filter(it, fn) {
    let i = 0;
    for (const value of it)
        if (fn(value, i++))
            yield value;
}
exports.filter = filter;
/** Maps values of an iterable. */
function* map(it, fn) {
    let i = 0;
    for (const value of it)
        yield fn(value, i++);
}
exports.map = map;
/** Concatenates multiple iterables to a single one. */
function* concat(...its) {
    for (const it of its)
        yield* it;
}
exports.concat = concat;
/** Repeatedly yields values from the same iterable. */
function* repeat(it) {
    for (;;)
        yield* it;
}
exports.repeat = repeat;
/** Always yields the same value. */
function* always(value) {
    for (;;)
        yield value;
}
exports.always = always;
/** Loops a generator function. */
function* loop(fn) {
    for (let i = 0;;)
        yield* fn(i++);
}
exports.loop = loop;
/** Yields values generated by a function. */
function* generate(fn) {
    for (let i = 0;;)
        yield fn(i++);
}
exports.generate = generate;
/** Yields a sequence of values derived from previous values. */
function* sequence(fn, first) {
    for (let i = 0, value = first;; value = fn(value, i++))
        yield value;
}
exports.sequence = sequence;
/** Yields a sequence of monotonically increasing numbers. */
function* range(start = 0, stop = Infinity, step = 1) {
    for (let number = start; number < stop; number += step)
        yield number;
}
exports.range = range;
/** Yields a sequence of matches. */
function* match(input, regexp) {
    for (let match; match = regexp.exec(input);)
        yield match;
}
exports.match = match;
/** Takes some amount values from an iterable. */
function* take(it, amount) {
    let i = 0;
    const itʹ = util_1.unwrap(it);
    const done = { done: true };
    yield* util_1.next(() => i++ < amount ? itʹ.next() : done);
}
exports.take = take;
/** Drops some amount values from an iterable. */
function* drop(it, amount) {
    const itʹ = util_1.wrap(util_1.unwrap(it)); // always return the same iterator
    for (const _ of take(itʹ, amount))
        ; // noop
    yield* itʹ;
}
exports.drop = drop;
