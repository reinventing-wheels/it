"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const util_1 = require("../util");
/** Calls a function for each value of an iterable. */
function forEach(it, fn) {
    let i = 0;
    for (const value of it)
        fn(value, i++);
}
exports.forEach = forEach;
/** Reduces an iterable to a single value. */
function reduce(it, fn, first) {
    let i = 0, acc = first;
    for (const value of it)
        acc = fn(acc, value, i++);
    return acc;
}
exports.reduce = reduce;
/** Filters values of an iterable. */
function* filter(it, fn) {
    let i = 0;
    for (const value of it)
        if (fn(value, i++))
            yield value;
}
exports.filter = filter;
/** Maps values of an iterable. */
function* map(it, fn) {
    let i = 0;
    for (const value of it)
        yield fn(value, i++);
}
exports.map = map;
/** Concatenates multiple iterables to a single one. */
function* concat(...its) {
    for (const it of its)
        yield* it;
}
exports.concat = concat;
/** Flattens an iterable. */
function* flatten(it) {
    for (const value of it)
        yield* value;
}
exports.flatten = flatten;
/** Yields values from an iterable in cycle. */
function* cycle(it) {
    for (;;)
        yield* it;
}
exports.cycle = cycle;
/** Repeatedly yields the same value. */
function* repeat(value) {
    for (;;)
        yield value;
}
exports.repeat = repeat;
/** Loops a generator function. */
function* loop(fn) {
    for (let i = 0;;)
        yield* fn(i++);
}
exports.loop = loop;
/** Yields values generated by a function. */
function* generate(fn) {
    for (let i = 0;;)
        yield fn(i++);
}
exports.generate = generate;
/** Yields a sequence of values derived from previous values. */
function* sequence(fn, first) {
    for (let i = 0, value = first;; value = fn(value, i++))
        yield value;
}
exports.sequence = sequence;
/** Yields a sequence of monotonically increasing numbers. */
function* range(start = 0, stop = Infinity, step = 1) {
    for (let number = start; number < stop; number += step)
        yield number;
}
exports.range = range;
/** Yields a sequence of matches. */
function* match(input, regexp) {
    for (let match; match = regexp.exec(input);)
        yield match;
}
exports.match = match;
/** Yields an iterable by chunks of specified size. */
function* chunk(it, size) {
    for (let chunk; (chunk = [...take(it, size)]).length;)
        yield chunk;
}
exports.chunk = chunk;
/** Zips multiple iterables to a single one. */
function* zip(...its) {
    const itsʹ = its.map(util_1.unwrap);
    yield* util_1.iter(() => {
        const rs = itsʹ.map(it => it.next());
        const r = rs.find(r => r.done) || util_1.value(rs.map(r => r.value));
        return r;
    });
}
exports.zip = zip;
/** Takes specified amount of values from an iterable. */
function* take(it, amount) {
    let i = 0;
    const itʹ = util_1.unwrap(it);
    yield* util_1.iter(() => i++ < amount ? itʹ.next() : util_1.done());
}
exports.take = take;
/** Drops specified amount of values from an iterable. */
function* drop(it, amount) {
    const itʹ = util_1.wrap(util_1.unwrap(it)); // always return the same iterator
    for (const _ of take(itʹ, amount))
        ; // noop
    yield* itʹ;
}
exports.drop = drop;
