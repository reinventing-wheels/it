(function (global, factory) {
  typeof exports === 'object' && typeof module !== 'undefined' ? factory(exports) :
  typeof define === 'function' && define.amd ? define(['exports'], factory) :
  (factory((global.it = {})));
}(this, (function (exports) { 'use strict';

  /** Extracts an iterator from an iterable. */
  const unwrap = (it) => it[Symbol.iterator]();
  /** Creates an iterable from an iterator. */
  const wrap = (it) => ({ [Symbol.iterator]: () => it });
  /** Creates an iterable from a function. */
  const iter = (next) => wrap({ next });
  /** Creates an iterator result with `done` set to true. */
  const done = () => ({ done: true });
  /** Creates an iterator result with specified `value`. */
  const value = (value) => ({ value });

  /** Calls a function for each value of an iterable. */
  function forEach(it, fn) {
      let i = 0;
      for (const value$$1 of it)
          fn(value$$1, i++);
  }
  /** Reduces an iterable to a single value. */
  function reduce(it, fn, first) {
      let i = 0, acc = first;
      for (const value$$1 of it)
          acc = fn(acc, value$$1, i++);
      return acc;
  }
  /** Filters values of an iterable. */
  function* filter(it, fn) {
      let i = 0;
      for (const value$$1 of it)
          if (fn(value$$1, i++))
              yield value$$1;
  }
  /** Maps values of an iterable. */
  function* map(it, fn) {
      let i = 0;
      for (const value$$1 of it)
          yield fn(value$$1, i++);
  }
  /** Concatenates multiple iterables to a single one. */
  function* concat(...its) {
      for (const it of its)
          yield* it;
  }
  /** Flattens an iterable. */
  function* flatten(it) {
      for (const value$$1 of it)
          yield* value$$1;
  }
  /** Yields values from an iterable in cycle. */
  function* cycle(it) {
      for (;;)
          yield* it;
  }
  /** Repeatedly yields the same value. */
  function* repeat(value$$1) {
      for (;;)
          yield value$$1;
  }
  /** Loops a generator function. */
  function* loop(fn) {
      for (let i = 0;;)
          yield* fn(i++);
  }
  /** Yields values generated by a function. */
  function* generate(fn) {
      for (let i = 0;;)
          yield fn(i++);
  }
  /** Yields a sequence of values derived from previous values. */
  function* sequence(fn, first) {
      for (let i = 0, value$$1 = first;; value$$1 = fn(value$$1, i++))
          yield value$$1;
  }
  /** Yields a sequence of monotonically increasing numbers. */
  function* range(start = 0, stop = Infinity, step = 1) {
      for (let number = start; number < stop; number += step)
          yield number;
  }
  /** Yields a sequence of matches. */
  function* match(input, regexp) {
      for (let match; match = regexp.exec(input);)
          yield match;
  }
  /** Yields an iterable by chunks of specified size. */
  function* chunk(it, size) {
      for (let chunk; (chunk = [...take(it, size)]).length;)
          yield chunk;
  }
  /** Zips multiple iterables to a single one. */
  function* zip(...its) {
      const itsʹ = its.map(unwrap);
      yield* iter(() => {
          const rs = itsʹ.map(it => it.next());
          const r = rs.find(r => r.done) || value(rs.map(r => r.value));
          return r;
      });
  }
  /** Takes specified amount of values from an iterable. */
  function* take(it, amount) {
      let i = 0;
      const itʹ = unwrap(it);
      yield* iter(() => i++ < amount ? itʹ.next() : done());
  }
  /** Drops specified amount of values from an iterable. */
  function* drop(it, amount) {
      const itʹ = wrap(unwrap(it)); // always return the same iterator
      for (const _ of take(itʹ, amount))
          ; // noop
      yield* itʹ;
  }

  var uc = ({
    forEach: forEach,
    reduce: reduce,
    filter: filter,
    map: map,
    concat: concat,
    flatten: flatten,
    cycle: cycle,
    repeat: repeat,
    loop: loop,
    generate: generate,
    sequence: sequence,
    range: range,
    match: match,
    chunk: chunk,
    zip: zip,
    take: take,
    drop: drop
  });

  /** Calls a function for each value of an iterable. */
  const forEach$1 = (fn) => (it) => forEach(it, fn);
  /** Reduces an iterable to a single value. */
  const reduce$1 = (fn) => (first) => (it) => reduce(it, fn, first);
  /** Filters values of an iterable. */
  const filter$1 = (fn) => (it) => filter(it, fn);
  /** Maps values of an iterable. */
  const map$1 = (fn) => (it) => map(it, fn);
  /** Yields a sequence of values derived from previous values. */
  const sequence$1 = (fn) => (first) => sequence(fn, first);
  /** Yields a sequence of monotonically increasing numbers. */
  const range$1 = (start) => (stop) => (step) => range(start, stop, step);
  /** Yields a sequence of matches. */
  const match$1 = (regexp) => (input) => match(input, regexp);
  /** Yields an iterable by chunks of specified size. */
  const chunk$1 = (size) => (it) => chunk(it, size);
  /** Takes specified amount of values from an iterable. */
  const take$1 = (amount) => (it) => take(it, amount);
  /** Drops specified amount of values from an iterable. */
  const drop$1 = (amount) => (it) => drop(it, amount);

  var c = ({
    forEach: forEach$1,
    reduce: reduce$1,
    filter: filter$1,
    map: map$1,
    sequence: sequence$1,
    range: range$1,
    match: match$1,
    chunk: chunk$1,
    take: take$1,
    drop: drop$1,
    concat: concat,
    flatten: flatten,
    cycle: cycle,
    repeat: repeat,
    loop: loop,
    generate: generate,
    zip: zip
  });

  const it = (it) => new It(it);
  class It {
      constructor(it) {
          this[Symbol.iterator] = it[Symbol.iterator].bind(it);
      }
      /** Repeatedly yields the same value. */
      static repeat(value) {
          return new It(repeat(value));
      }
      /** Loops a generator function. */
      static loop(fn) {
          return new It(loop(fn));
      }
      /** Yields values generated by a function. */
      static generate(fn) {
          return new It(generate(fn));
      }
      /** Yields a sequence of values derived from previous values. */
      static sequence(fn, first) {
          return new It(sequence(fn, first));
      }
      /** Yields a sequence of monotonically increasing numbers. */
      static range(start, stop, step) {
          return new It(range(start, stop, step));
      }
      /** Yields a sequence of matches. */
      static match(input, regexp) {
          return new It(match(input, regexp));
      }
      /** Casts the iterable to other data structure. */
      cast(fn) {
          return fn(this);
      }
      /** Calls a function for each value of the iterable. */
      forEach(fn) {
          forEach(this, fn);
      }
      /** Reduces the iterable to a single value. */
      reduce(fn, first) {
          return reduce(this, fn, first);
      }
      /** Filters values of the iterable. */
      filter(fn) {
          return new It(filter(this, fn));
      }
      /** Maps values of the iterable. */
      map(fn) {
          return new It(map(this, fn));
      }
      /** Concatenates multiple iterables to a single one. */
      concat(...its) {
          return new It(concat(this, ...its));
      }
      /** Flattens the iterable. */
      flatten() {
          return new It(flatten(this));
      }
      /** Yields values from the iterable in cycle. */
      cycle() {
          return new It(cycle(this));
      }
      /** Yields the iterable by chunks of specified size. */
      chunk(size) {
          return new It(chunk(this, size));
      }
      /** Zips multiple iterables to a single one. */
      zip(...its) {
          return new It(zip(this, ...its));
      }
      /** Takes specified amount of values from the iterable. */
      take(amount) {
          return new It(take(this, amount));
      }
      /** Drops specified amount of values from the iterable. */
      drop(amount) {
          return new It(drop(this, amount));
      }
  }
  It.uncurried = uc;
  It.curried = c;

  exports.uncurried = uc;
  exports.curried = c;
  exports.chunkʹ = chunk;
  exports.concatʹ = concat;
  exports.cycleʹ = cycle;
  exports.dropʹ = drop;
  exports.filterʹ = filter;
  exports.flattenʹ = flatten;
  exports.forEachʹ = forEach;
  exports.generateʹ = generate;
  exports.loopʹ = loop;
  exports.mapʹ = map;
  exports.matchʹ = match;
  exports.rangeʹ = range;
  exports.reduceʹ = reduce;
  exports.repeatʹ = repeat;
  exports.sequenceʹ = sequence;
  exports.takeʹ = take;
  exports.zipʹ = zip;
  exports.forEach = forEach$1;
  exports.reduce = reduce$1;
  exports.filter = filter$1;
  exports.map = map$1;
  exports.sequence = sequence$1;
  exports.range = range$1;
  exports.match = match$1;
  exports.chunk = chunk$1;
  exports.take = take$1;
  exports.drop = drop$1;
  exports.concat = concat;
  exports.flatten = flatten;
  exports.cycle = cycle;
  exports.repeat = repeat;
  exports.loop = loop;
  exports.generate = generate;
  exports.zip = zip;
  exports.it = it;
  exports.It = It;

  Object.defineProperty(exports, '__esModule', { value: true });

})));
//# sourceMappingURL=it.js.map
