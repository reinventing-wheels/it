{"version":3,"file":"it.min.js","sources":["../../src/util.ts","../../src/functions/uncurried.ts","../../src/functions/curried.ts","../../src/it.ts"],"sourcesContent":["/** Extracts an iterator from an iterable. */\nexport const unwrap = <T>(it: Iterable<T>): Iterator<T> =>\n  it[Symbol.iterator]()\n\n/** Creates an iterable from an iterator. */\nexport const wrap = <T>(it: Iterator<T>): Iterable<T> =>\n  ({ [Symbol.iterator]: () => it })\n\n/** Creates an iterable from a function. */\nexport const iter = <T>(next: () => IteratorResult<T>) =>\n  wrap({ next })\n\n/** Creates an iterator result with `done` set to true. */\nexport const done = <T>() =>\n  ({ done: true }) as IteratorResult<T>\n\n/** Creates an iterator result with specified `value`. */\nexport const value = <T>(value: T) =>\n  ({ value }) as IteratorResult<T>\n","// tslint:disable:only-arrow-functions\nimport { Callback, Reducer } from '../types'\nimport { unwrap, wrap, iter, done, value } from '../util'\n\n/** Calls a function for each value of an iterable. */\nexport function forEach<T>(it: Iterable<T>, fn: Callback<T, void>) {\n  let i = 0\n  for (const value of it)\n    fn(value, i++)\n}\n\n/** Reduces an iterable to a single value. */\nexport function reduce<T, U>(it: Iterable<T>, fn: Reducer<T, U>, first: U) {\n  let i = 0, acc = first\n  for (const value of it)\n    acc = fn(acc, value, i++)\n  return acc\n}\n\n/** Filters values of an iterable. */\nexport function* filter<T>(it: Iterable<T>, fn: Callback<T, boolean>) {\n  let i = 0\n  for (const value of it)\n    if (fn(value, i++))\n      yield value\n}\n\n/** Maps values of an iterable. */\nexport function* map<T, U>(it: Iterable<T>, fn: Callback<T, U>) {\n  let i = 0\n  for (const value of it)\n    yield fn(value, i++)\n}\n\n/** Concatenates multiple iterables to a single one. */\nexport function* concat<T>(...its: Iterable<T>[]) {\n  for (const it of its)\n    yield* it\n}\n\n/** Flattens an iterable. */\nexport function* flatten<T>(it: Iterable<Iterable<T>>) {\n  for (const value of it)\n    yield* value\n}\n\n/** Yields values from an iterable in cycle. */\nexport function* cycle<T>(it: Iterable<T>) {\n  for (;;)\n    yield* it\n}\n\n/** Repeatedly yields the same value. */\nexport function* repeat<T>(value: T) {\n  for (;;)\n    yield value\n}\n\n/** Loops a generator function. */\nexport function* loop<T>(fn: (index: number) => Iterable<T>) {\n  for (let i = 0;;)\n    yield* fn(i++)\n}\n\n/** Yields values generated by a function. */\nexport function* generate<T>(fn: (index: number) => T) {\n  for (let i = 0;;)\n    yield fn(i++)\n}\n\n/** Yields a sequence of values derived from previous values. */\nexport function* sequence<T>(fn: Callback<T, T>, first: T) {\n  for (let i = 0, value = first;; value = fn(value, i++))\n    yield value\n}\n\n/** Yields a sequence of monotonically increasing numbers. */\nexport function* range(start = 0, stop = Infinity, step = 1) {\n  for (let number = start; number < stop; number += step)\n    yield number\n}\n\n/** Yields a sequence of matches. */\nexport function* match(input: string, regexp: RegExp) {\n  for (let match; match = regexp.exec(input);)\n    yield match\n}\n\n/** Yields an iterable by chunks of specified size. */\nexport function* chunk<T>(it: Iterable<T>, size: number) {\n  for (let chunk; (chunk = [...take(it, size)]).length;)\n    yield chunk\n}\n\n/** Zips multiple iterables to a single one. */\nexport function* zip<T>(...its: Iterable<T>[]) {\n  const itsʹ = its.map(unwrap)\n  yield* iter(() => {\n    const rs = itsʹ.map(it => it.next())\n    const r = rs.find(r => r.done) || value(rs.map(r => r.value))\n    return r as IteratorResult<T[]>\n  })\n}\n\n/** Takes specified amount of values from an iterable. */\nexport function* take<T>(it: Iterable<T>, amount: number) {\n  let i = 0\n  const itʹ = unwrap(it)\n  yield* iter(() => i++ < amount ? itʹ.next() : done<T>())\n}\n\n/** Drops specified amount of values from an iterable. */\nexport function* drop<T>(it: Iterable<T>, amount: number) {\n  const itʹ = wrap(unwrap(it)) // always return the same iterator\n  for (const _ of take(itʹ, amount)); // noop\n  yield* itʹ\n}\n","import { Callback, Reducer } from '../types'\nimport * as uc from './uncurried'\n\n/** Calls a function for each value of an iterable. */\nexport const forEach = <T>(fn: Callback<T, void>) => (it: Iterable<T>) =>\n  uc.forEach(it, fn)\n\n/** Reduces an iterable to a single value. */\nexport const reduce = <T, U>(fn: Reducer<T, U>) => (first: U) => (it: Iterable<T>) =>\n  uc.reduce(it, fn, first)\n\n/** Filters values of an iterable. */\nexport const filter = <T>(fn: Callback<T, boolean>) => (it: Iterable<T>) =>\n  uc.filter(it, fn)\n\n/** Maps values of an iterable. */\nexport const map = <T, U>(fn: Callback<T, U>) => (it: Iterable<T>) =>\n  uc.map(it, fn)\n\n/** Yields a sequence of values derived from previous values. */\nexport const sequence = <T>(fn: Callback<T, T>) => (first: T) =>\n  uc.sequence(fn, first)\n\n/** Yields a sequence of monotonically increasing numbers. */\nexport const range = (start?: number) => (stop?: number) => (step?: number) =>\n  uc.range(start, stop, step)\n\n/** Yields a sequence of matches. */\nexport const match = (regexp: RegExp) => (input: string) =>\n  uc.match(input, regexp)\n\n/** Yields an iterable by chunks of specified size. */\nexport const chunk = (size: number) => <T>(it: Iterable<T>) =>\n  uc.chunk(it, size)\n\n/** Takes specified amount of values from an iterable. */\nexport const take = (amount: number) => <T>(it: Iterable<T>) =>\n  uc.take(it, amount)\n\n/** Drops specified amount of values from an iterable. */\nexport const drop = (amount: number) => <T>(it: Iterable<T>) =>\n  uc.drop(it, amount)\n\nexport { concat, flatten, cycle, repeat, loop, generate, zip } from './uncurried'\n","import { Callback, Reducer, Flatten } from './types'\nimport * as uc from './functions/uncurried'\nimport * as c from './functions/curried'\n\nexport const it = <T>(it: Iterable<T>) => new It(it)\n\nexport class It<T> implements Iterable<T> {\n  [Symbol.iterator]: () => Iterator<T>\n\n  static uncurried = uc\n  static curried = c\n\n  constructor(it: Iterable<T>) {\n    this[Symbol.iterator] = it[Symbol.iterator].bind(it)\n  }\n\n  /** Repeatedly yields the same value. */\n  static repeat<T>(value: T) {\n    return new It(uc.repeat(value))\n  }\n\n  /** Loops a generator function. */\n  static loop<T>(fn: (index: number) => Iterable<T>) {\n    return new It(uc.loop(fn))\n  }\n\n  /** Yields values generated by a function. */\n  static generate<T>(fn: (index: number) => T) {\n    return new It(uc.generate(fn))\n  }\n\n  /** Yields a sequence of values derived from previous values. */\n  static sequence<T>(fn: Callback<T, T>, first: T) {\n    return new It(uc.sequence(fn, first))\n  }\n\n  /** Yields a sequence of monotonically increasing numbers. */\n  static range(start?: number, stop?: number, step?: number) {\n    return new It(uc.range(start, stop, step))\n  }\n\n  /** Yields a sequence of matches. */\n  static match(input: string, regexp: RegExp) {\n    return new It(uc.match(input, regexp))\n  }\n\n  /** Casts the iterable to other data structure. */\n  cast<T>(fn: (it: this) => T) {\n    return fn(this)\n  }\n\n  /** Calls a function for each value of the iterable. */\n  forEach(fn: Callback<T, void>) {\n    uc.forEach(this, fn)\n  }\n\n  /** Reduces the iterable to a single value. */\n  reduce<U>(fn: Reducer<T, U>, first: U) {\n    return uc.reduce(this, fn, first)\n  }\n\n  /** Filters values of the iterable. */\n  filter(fn: Callback<T, boolean>) {\n    return new It(uc.filter(this, fn))\n  }\n\n  /** Maps values of the iterable. */\n  map<U>(fn: Callback<T, U>) {\n    return new It(uc.map(this, fn))\n  }\n\n  /** Concatenates multiple iterables to a single one. */\n  concat<U>(...its: Iterable<U>[]) {\n    return new It(uc.concat<T | U>(this, ...its))\n  }\n\n  /** Flattens the iterable. */\n  flatten() {\n    return new It(uc.flatten<Flatten<T>>(this as any))\n  }\n\n  /** Yields values from the iterable in cycle. */\n  cycle() {\n    return new It(uc.cycle(this))\n  }\n\n  /** Yields the iterable by chunks of specified size. */\n  chunk(size: number) {\n    return new It(uc.chunk(this, size))\n  }\n\n  /** Zips multiple iterables to a single one. */\n  zip<U>(...its: Iterable<U>[]) {\n    return new It(uc.zip<T | U>(this, ...its))\n  }\n\n  /** Takes specified amount of values from the iterable. */\n  take(amount: number) {\n    return new It(uc.take(this, amount))\n  }\n\n  /** Drops specified amount of values from the iterable. */\n  drop(amount: number) {\n    return new It(uc.drop(this, amount))\n  }\n}\n"],"names":["unwrap","it","Symbol","iterator","wrap","[object Object]","iter","next","done","value","forEach","fn","i","reduce","first","acc","filter","map","concat","its","flatten","cycle","repeat","loop","generate","sequence","range","start","stop","Infinity","step","number","match","input","regexp","exec","chunk","size","take","length","zip","itsʹ","rs","find","r","amount","itʹ","drop","_","uc.forEach","uc.reduce","uc.filter","uc.map","uc.sequence","uc.range","uc.match","uc.chunk","uc.take","uc.drop","It","this","bind","uc.repeat","uc.loop","uc.generate","uc.concat","uc.flatten","uc.cycle","uc.zip","uc","c"],"mappings":"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"}