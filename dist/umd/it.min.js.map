{"version":3,"file":"it.min.js","sources":["../../src/util.ts","../../src/functions/uncurried.ts","../../src/functions/curried.ts","../../src/it.ts"],"sourcesContent":["export const unwrap = <T>(it: Iterable<T>): Iterator<T> =>\n  it[Symbol.iterator]()\n\nexport const wrap = <T>(it: Iterator<T>): Iterable<T> =>\n  ({ [Symbol.iterator]: () => it })\n\nexport const next = <T>(next: () => IteratorResult<T>) =>\n  wrap({ next })\n","// tslint:disable:only-arrow-functions\nimport { unwrap, wrap, next } from '../util'\n\n/** Calls a function for each value of an iterable. */\nexport function forEach<T>(it: Iterable<T>, fn: (value: T, index: number) => void) {\n  let i = 0\n  for (const value of it)\n    fn(value, i++)\n}\n\n/** Reduces an iterable to a single value. */\nexport function reduce<T, U>(it: Iterable<T>, fn: (previous: U, current: T, index: number) => U, first: U) {\n  let i = 0, acc = first\n  for (const value of it)\n    acc = fn(acc, value, i++)\n  return acc\n}\n\n/** Filters values of an iterable. */\nexport function* filter<T>(it: Iterable<T>, fn: (value: T, index: number) => boolean) {\n  let i = 0\n  for (const value of it)\n    if (fn(value, i++))\n      yield value\n}\n\n/** Maps values of an iterable. */\nexport function* map<T, U>(it: Iterable<T>, fn: (value: T, index: number) => U) {\n  let i = 0\n  for (const value of it)\n    yield fn(value, i++)\n}\n\n/** Concatenates multiple iterables to a single one. */\nexport function* concat<T>(...its: Iterable<T>[]) {\n  for (const it of its)\n    yield* it\n}\n\n/** Yields values from an iterable in cycle. */\nexport function* cycle<T>(it: Iterable<T>) {\n  for (;;)\n    yield* it\n}\n\n/** Repeatedly yields the same value. */\nexport function* repeat<T>(value: T) {\n  for (;;)\n    yield value\n}\n\n/** Loops a generator function. */\nexport function* loop<T>(fn: (index: number) => Iterable<T>) {\n  for (let i = 0;;)\n    yield* fn(i++)\n}\n\n/** Yields values generated by a function. */\nexport function* generate<T>(fn: (index: number) => T) {\n  for (let i = 0;;)\n    yield fn(i++)\n}\n\n/** Yields a sequence of values derived from previous values. */\nexport function* sequence<T>(fn: (previous: T, index: number) => T, first: T) {\n  for (let i = 0, value = first;; value = fn(value, i++))\n    yield value\n}\n\n/** Yields a sequence of monotonically increasing numbers. */\nexport function* range(start = 0, stop = Infinity, step = 1) {\n  for (let number = start; number < stop; number += step)\n    yield number\n}\n\n/** Yields a sequence of matches. */\nexport function* match(input: string, regexp: RegExp) {\n  for (let match; match = regexp.exec(input);)\n    yield match\n}\n\n/** Zips multiple iterables to a single one. */\nexport function* zip<T>(...its: Iterable<T>[]) {\n  const itsʹ = its.map(unwrap)\n  yield* next(() => {\n    const results = itsʹ.map(it => it.next())\n    const result = results.find(r => r.done) || { value: results.map(r => r.value) }\n    return result as IteratorResult<T[]>\n  })\n}\n\n/** Takes some amount of values from an iterable. */\nexport function* take<T>(it: Iterable<T>, amount: number) {\n  let i = 0\n  const itʹ = unwrap(it)\n  const done = { done: true } as IteratorResult<T>\n  yield* next(() => i++ < amount ? itʹ.next() : done)\n}\n\n/** Drops some amount of values from an iterable. */\nexport function* drop<T>(it: Iterable<T>, amount: number) {\n  const itʹ = wrap(unwrap(it)) // always return the same iterator\n  for (const _ of take(itʹ, amount)); // noop\n  yield* itʹ\n}\n","import * as uc from './uncurried'\n\n/** Calls a function for each value of an iterable. */\nexport const forEach = <T>(fn: (value: T, index: number) => void) => (it: Iterable<T>) =>\n  uc.forEach(it, fn)\n\n/** Reduces an iterable to a single value. */\nexport const reduce = <T, U>(fn: (previous: U, current: T, index: number) => U) => (first: U) => (it: Iterable<T>) =>\n  uc.reduce(it, fn, first)\n\n/** Filters values of an iterable. */\nexport const filter = <T>(fn: (value: T, index: number) => boolean) => (it: Iterable<T>) =>\n  uc.filter(it, fn)\n\n/** Maps values of an iterable. */\nexport const map = <T, U>(fn: (value: T, index: number) => U) => (it: Iterable<T>) =>\n  uc.map(it, fn)\n\n/** Yields a sequence of values derived from previous values. */\nexport const sequence = <T>(fn: (previous: T, index: number) => T) => (first: T) =>\n  uc.sequence(fn, first)\n\n/** Yields a sequence of monotonically increasing numbers. */\nexport const range = (start?: number) => (stop?: number) => (step?: number) =>\n  uc.range(start, stop, step)\n\n/** Yields a sequence of matches. */\nexport const match = (regexp: RegExp) => (input: string) =>\n  uc.match(input, regexp)\n\n/** Takes some amount of values from an iterable. */\nexport const take = (amount: number) => <T>(it: Iterable<T>) =>\n  uc.take(it, amount)\n\n/** Drops some amount of values from an iterable. */\nexport const drop = (amount: number) => <T>(it: Iterable<T>) =>\n  uc.drop(it, amount)\n\nexport { concat, cycle, repeat, loop, generate, zip } from './uncurried'\n","import { forEach, reduce, filter, map, concat, cycle, zip, take, drop } from './functions/uncurried'\nimport { repeat, loop, generate, sequence, range, match } from './functions/uncurried'\nimport * as uncurried from './functions/uncurried'\nimport * as curried from './functions/curried'\n\nexport const it = <T>(it: Iterable<T>) => new It(it)\n\nexport class It<T> implements Iterable<T> {\n  [Symbol.iterator]: () => Iterator<T>\n\n  static uncurried = uncurried\n  static curried = curried\n\n  /** Repeatedly yields the same value. */\n  static repeat<T>(value: T) {\n    return new It(repeat(value))\n  }\n\n  /** Loops a generator function. */\n  static loop<T>(fn: (index: number) => Iterable<T>) {\n    return new It(loop(fn))\n  }\n\n  /** Yields values generated by a function. */\n  static generate<T>(fn: (index: number) => T) {\n    return new It(generate(fn))\n  }\n\n  /** Yields a sequence of values derived from previous values. */\n  static sequence<T>(fn: (previous: T, index: number) => T, first: T) {\n    return new It(sequence(fn, first))\n  }\n\n  /** Yields a sequence of monotonically increasing numbers. */\n  static range(start?: number, stop?: number, step?: number) {\n    return new It(range(start, stop, step))\n  }\n\n  /** Yields a sequence of matches. */\n  static match(input: string, regexp: RegExp) {\n    return new It(match(input, regexp))\n  }\n\n  constructor(it: Iterable<T>) {\n    this[Symbol.iterator] = it[Symbol.iterator].bind(it)\n  }\n\n  /** Casts the iterable to other data structure. */\n  cast<T>(fn: (it: this) => T) {\n    return fn(this)\n  }\n\n  /** Calls a function for each value of the iterable. */\n  forEach(fn: (value: T, index: number) => void) {\n    forEach(this, fn)\n  }\n\n  /** Reduces the iterable to a single value. */\n  reduce<U>(fn: (previous: U, current: T, index: number) => U, first: U) {\n    return reduce(this, fn, first)\n  }\n\n  /** Filters values of the iterable. */\n  filter(fn: (value: T, index: number) => boolean) {\n    return new It(filter(this, fn))\n  }\n\n  /** Maps values of the iterable. */\n  map<U>(fn: (value: T, index: number) => U) {\n    return new It(map(this, fn))\n  }\n\n  /** Concatenates multiple iterables to a single one. */\n  concat<U>(...its: Iterable<U>[]) {\n    return new It(concat<T | U>(this, ...its))\n  }\n\n  /** Yields values from the iterable in cycle. */\n  cycle() {\n    return new It(cycle(this))\n  }\n\n  /** Zips multiple iterables to a single one. */\n  zip<U>(...its: Iterable<U>[]) {\n    return new It(zip<T | U>(this, ...its))\n  }\n\n  /** Takes some amount of values from the iterable. */\n  take(amount: number) {\n    return new It(take(this, amount))\n  }\n\n  /** Drops some amount of values from the iterable. */\n  drop(amount: number) {\n    return new It(drop(this, amount))\n  }\n}\n"],"names":["unwrap","it","Symbol","iterator","wrap","[object Object]","next","forEach","fn","i","value","reduce","first","acc","filter","map","concat","its","cycle","repeat","loop","generate","sequence","range","start","stop","Infinity","step","number","match","input","regexp","exec","zip","itsʹ","results","find","r","done","take","amount","itʹ","drop","_","uc.forEach","uc.reduce","uc.filter","uc.map","uc.sequence","uc.range","uc.match","uc.take","uc.drop","It","this","bind","uncurried","curried"],"mappings":"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"}