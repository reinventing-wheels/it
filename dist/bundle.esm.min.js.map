{"version":3,"file":"bundle.esm.min.js","sources":["../src/uncurried/cast.ts","../src/uncurried/chain.ts","../src/uncurried/chunk.ts","../src/uncurried/count.ts","../src/uncurried/collect.ts","../src/uncurried/cycle.ts","../src/uncurried/drop.ts","../src/uncurried/dropWhile.ts","../src/uncurried/enumerate.ts","../src/uncurried/every.ts","../src/uncurried/filter.ts","../src/uncurried/find.ts","../src/uncurried/first.ts","../src/uncurried/flatMap.ts","../src/uncurried/flatten.ts","../src/uncurried/forEach.ts","../src/uncurried/generate.ts","../src/uncurried/inspect.ts","../src/uncurried/last.ts","../src/uncurried/length.ts","../src/uncurried/loop.ts","../src/uncurried/map.ts","../src/uncurried/match.ts","../src/uncurried/nth.ts","../src/uncurried/range.ts","../src/uncurried/reduce.ts","../src/uncurried/repeat.ts","../src/uncurried/sequence.ts","../src/uncurried/some.ts","../src/uncurried/take.ts","../src/uncurried/takeWhile.ts","../src/uncurried/unique.ts","../src/uncurried/zip.ts","../src/util.ts","../src/curried/cast.ts","../src/curried/chunk.ts","../src/curried/count.ts","../src/curried/cycle.ts","../src/curried/drop.ts","../src/curried/dropWhile.ts","../src/curried/every.ts","../src/curried/filter.ts","../src/curried/find.ts","../src/curried/flatMap.ts","../src/curried/forEach.ts","../src/curried/generate.ts","../src/curried/inspect.ts","../src/curried/loop.ts","../src/curried/map.ts","../src/curried/match.ts","../src/curried/nth.ts","../src/curried/range.ts","../src/curried/reduce.ts","../src/curried/repeat.ts","../src/curried/sequence.ts","../src/curried/some.ts","../src/curried/take.ts","../src/curried/takeWhile.ts","../src/it.ts"],"sourcesContent":["/**\n * @example\n * cast([1, 2, 3], it => new Uint8Array(it)) // Uint8Array\n * cast([1, 2, 3], it => new Set(it)) // Set<number>\n * cast('foobar', it => new Set(it)) // Set<string>\n */\nexport function cast<T, U>(it: Iterable<T>, fn: (it: Iterable<T>) => U) {\n  return fn(it)\n}\n","/**\n * @example\n * chain([1, 2], [3, 4], [5]) // (1 2 3 4 5)\n * chain('foo', 'bar') // (f o o b a r)\n */\nexport function* chain<T>(...its: Iterable<T>[]) {\n  for (const it of its)\n    yield* it\n}\n","/**\n * @example\n * chunk([1, 2, 3, 4, 5], 2) // ([1 2] [3 4] [5])\n * chunk('foobar', 3) // ([f o o] [b a r])\n */\nexport function* chunk<T>(it: Iterable<T>, size: number) {\n  const chunk = []\n  for (const value of it)\n    if (chunk.push(value) >= size)\n      yield chunk.splice(0)\n  if (chunk.length)\n    yield chunk\n}\n","/**\n * @example\n * count() // (0 1 2 3 4 …)\n * count(5) // (5 6 7 8 9 …)\n * count(5, -1) // (5 4 3 2 1 …)\n * count(0, -2) // (0 -2 -4 -6 …)\n */\nexport function* count(start = 0, step = 1) {\n  for (let n = start; ; n += step)\n    yield n\n}\n","/**\n * @example\n * collect([1, 2, 3, 4, 5]) // [1 2 3 4 5]\n * collect('foobar') // [f o o b a r]\n */\nexport function collect<T>(it: Iterable<T>) {\n  return [...it]\n}\n","/**\n * @example\n * cycle([1, 2, 3], 2) // (1 2 3 1 2 3)\n * cycle([1, 2, 3]) // (1 2 3 1 2 3 …)\n * cycle('foo') // (f o o f o …)\n */\nexport function* cycle<T>(it: Iterable<T>, times = Infinity) {\n  for (let i = 0; i < times; i++)\n    yield* it\n}\n","import { lock } from '../util'\n\n/**\n * @example\n * drop([1, 2, 3, 4, 5], 2) // (3 4 5)\n * drop('foobar', 3) // (b a r)\n */\nexport function* drop<T>(it: Iterable<T>, amount = 1) {\n  const itʹ = lock(it)\n  let i = 0\n  for (const value of itʹ) {\n    if (i++ >= amount) {\n      yield value\n      yield* itʹ\n    }\n  }\n}\n","import { Callback } from '../types'\nimport { lock } from '../util'\n\n/**\n * @example\n * dropWhile([1, 2, 3, 4, 5], n => n < 3) // (3 4 5)\n * dropWhile('foobar', c => c != 'b') // (b a r)\n */\nexport function* dropWhile<T>(it: Iterable<T>, fn: Callback<T, boolean>) {\n  const itʹ = lock(it)\n  let i = 0\n  for (const value of itʹ) {\n    if (!fn(value, i++)) {\n      yield value\n      yield* itʹ\n    }\n  }\n}\n","/**\n * @example\n * enumerate(['foo', 'bar']) // ([0 foo] [1 bar])\n * enumerate('foo') // ([0 f] [1 o] [2 o])\n */\nexport function* enumerate<T>(it: Iterable<T>) {\n  let i = 0\n  for (const value of it)\n    yield [i++, value] as [number, T]\n}\n","import { Callback } from '../types'\n\n/**\n * @example\n * every([1, 2, 3], n => n > 0) // true\n * every([1, 2, 3], n => n > 1) // false\n */\nexport function every<T>(it: Iterable<T>, fn: Callback<T, boolean>) {\n  let i = 0\n  for (const value of it)\n    if (!fn(value, i++))\n      return false\n  return true\n}\n","import { Callback } from '../types'\n\n/**\n * @example\n * filter([1, 2, 3, 4, 5], n => n%2 == 0) // (2 4)\n * filter([1, 2, 3, 4, 5], n => n%2 != 0) // (1 3 5)\n * filter('foobar', c => c != 'o') // (f b a r)\n */\nexport function* filter<T>(it: Iterable<T>, fn: Callback<T, boolean>) {\n  let i = 0\n  for (const value of it)\n    if (fn(value, i++))\n      yield value\n}\n","import { Callback } from '../types'\n\n/**\n * @example\n * find([1, 2, 3], n => n%2 == 0) // 2\n * find([1, 2, 3], n => n%2 != 0) // 1\n * find('foobar', c => c != 'f') // o\n */\nexport function find<T>(it: Iterable<T>, fn: Callback<T, boolean>) {\n  let i = 0\n  for (const value of it)\n    if (fn(value, i++))\n      return value\n}\n","import { lock } from '../util'\n\n/**\n * @example\n * first([1, 2, 3]) // 1\n * first('foobar') // f\n */\nexport function first<T>(it: Iterable<T>) {\n  for (const value of lock(it))\n    return value\n}\n","import { Callback } from '../types'\n\n/**\n * @example\n * flatMap([1, 2, 3], n => [-n, +n]) // (-1 1 -2 2 -3 3)\n * flatMap(['foo', 'bar'], s => s) // (f o o b a r)\n */\nexport function* flatMap<T, U>(it: Iterable<T>, fn: Callback<T, U[]>) {\n  let i = 0\n  for (const value of it)\n    yield* fn(value, i++)\n}\n","/**\n * @example\n * flatten([[1, 2], [3, 4], [5]]) // (1 2 3 4 5)\n * flatten(['foo', 'bar']) // (f o o b a r)\n */\nexport function* flatten<T>(it: Iterable<Iterable<T>>) {\n  for (const value of it)\n    yield* value\n}\n","import { Callback } from '../types'\n\n/**\n * @example\n * forEach([1, 2, 3, 4, 5], n => log(n))\n * forEach('foobar', (c, i) => log(i, c))\n */\nexport function forEach<T>(it: Iterable<T>, fn: Callback<T, void>) {\n  let i = 0\n  for (const value of it)\n    fn(value, i++)\n}\n","/**\n * @example\n * generate(Math.random, 5) // 5 random numbers\n * generate(i => i, 5) // (0 1 2 3 4)\n * generate(i => i) // (0 1 2 3 4 …)\n */\nexport function* generate<T>(fn: (index: number) => T, times = Infinity) {\n  for (let i = 0; i < times; i++)\n    yield fn(i)\n}\n","import { Callback } from '../types'\n\n/**\n * @example\n * inspect([1, 2, 3, 4, 5], n => log(n)) // (1 2 3 4 5)\n * inspect('foobar', (c, i) => log(i, c)) // (f o …)\n */\nexport function* inspect<T>(it: Iterable<T>, fn: Callback<T, void>) {\n  let i = 0\n  for (const value of it) {\n    fn(value, i++)\n    yield value\n  }\n}\n","/**\n * @example\n * last([1, 2, 3]) // 3\n * last('foobar') // r\n */\nexport function last<T>(it: Iterable<T>) {\n  let value\n  for (value of it)\n    ; // noop\n  return value\n}\n","/**\n * @example\n * length([1, 2, 3]) // 3\n * length('foobar') // 6\n */\nexport function length<T>(it: Iterable<T>) {\n  let i = 0\n  for (const _ of it)\n    i++\n  return i\n}\n","/**\n * @example\n * function* countTo3() { for (let i = 1; i <= 3; i++) yield i }\n * function* countTo(n) { for (let i = 1; i <= n; i++) yield i }\n * loop(countTo3) // (1 2 3 1 2 3 1 2 3 …)\n * loop(countTo3, 3) // (1 2 3 1 2 3 1 2 3)\n * loop(countTo, 4) // (1 1 2 1 2 3 1 2 3 4)\n */\nexport function* loop<T>(fn: (index: number) => Iterable<T>, times = Infinity) {\n  for (let i = 0; i < times; i++)\n    yield* fn(i)\n}\n","import { Callback } from '../types'\n\n/**\n * @example\n * map([1, 2, 3, 4, 5], n => 2*n) // (2 4 6 8 10)\n * map('foo', c => c.charCodeAt(0)) // (102 111 111)\n */\nexport function* map<T, U>(it: Iterable<T>, fn: Callback<T, U>) {\n  let i = 0\n  for (const value of it)\n    yield fn(value, i++)\n}\n","/**\n * @example\n * // ([foo f oo] [bar b ar] [baz b az])\n * match('foobarbaz', /(f|b)(..)/g)\n */\nexport function* match(input: string, regexp: RegExp) {\n  // eslint-disable-next-line no-cond-assign\n  for (let match; match = regexp.exec(input);)\n    yield match\n}\n","/**\n * @example\n * nth([1, 2, 3], 1) // 2\n * nth('foobar', 0) // f\n * nth('foobar', 3) // b\n */\nexport function nth<T>(it: Iterable<T>, n: number) {\n  let i = 0\n  for (const value of it)\n    if (i++ >= n)\n      return value\n}\n","/**\n * @example\n * range() // (0 1 2 3 4 …)\n * range(0, 5) // (0 1 2 3 4)\n * range(1, 10, 2) // (1 3 5 7 9)\n */\nexport function* range(start = 0, stop = Infinity, step = 1) {\n  for (let n = start; n < stop; n += step)\n    yield n\n}\n","import { Reducer } from '../types'\n\n/**\n * @example\n * reduce([1, 2, 3], (acc, n) => acc + n, 0) // 6\n * reduce([1, 2, 3], (acc, n) => acc + n, '') // 123\n * reduce('foo', (map, c, i) => map.set(i, c), new Map) // Map\n */\nexport function reduce<T, U>(it: Iterable<T>, fn: Reducer<T, U>, first: U) {\n  let i = 0, acc = first\n  for (const value of it)\n    acc = fn(acc, value, i++)\n  return acc\n}\n","/**\n * @example\n * repeat(42) // (42 42 42 …)\n * repeat(42, 5) // (42 42 42 42 42)\n * repeat('foo', 3) // (foo foo foo)\n */\nexport function* repeat<T>(value: T, times = Infinity) {\n  for (let i = 0; i < times; i++)\n    yield value\n}\n","import { Callback } from '../types'\n\n/**\n * @example\n * sequence(n => n+1, 1) // (1 2 3 4 5 …)\n * sequence(n => n*2, 1, 7) // (1 2 4 8 16 32 64)\n * sequence(n => n**2, 2, 5) // (2 4 16 256 65536)\n */\nexport function* sequence<T>(fn: Callback<T, T>, first: T, length = Infinity) {\n  for (let i = 0, value = first; i < length; value = fn(value, i++))\n    yield value\n}\n","import { Callback } from '../types'\n\n/**\n * @example\n * some([1, 2, 3], n => n < 2) // true\n * some([1, 2, 3], n => n < 1) // false\n */\nexport function some<T>(it: Iterable<T>, fn: Callback<T, boolean>) {\n  let i = 0\n  for (const value of it)\n    if (fn(value, i++))\n      return true\n  return false\n}\n","import { lock } from '../util'\n\n/**\n * @example\n * take([1, 2, 3, 4, 5], 3) // (1 2 3)\n * take('foobar', 3) // (f o o)\n */\nexport function* take<T>(it: Iterable<T>, amount = 1) {\n  let i = 0\n  for (const value of amount > 0 ? lock(it) : []) {\n    yield value\n    if (++i >= amount)\n      return\n  }\n}\n","import { Callback } from '../types'\n\n/**\n * @example\n * takeWhile([1, 2, 3, 4, 5], n => n < 4) // (1 2 3)\n * takeWhile('foobar', c => c != 'b') // (f o o)\n */\nexport function* takeWhile<T>(it: Iterable<T>, fn: Callback<T, boolean>) {\n  let i = 0\n  for (const value of it) {\n    if (!fn(value, i++))\n      return\n    yield value\n  }\n}\n","/**\n * @example\n * unique([1, 3, 3, 7]) // (1 3 7)\n * unique('foobar') // (f o b a r)\n */\nexport function* unique<T>(it: Iterable<T>) {\n  const set = new Set<T>()\n  for (const value of it) {\n    if (!set.has(value)) {\n      set.add(value)\n      yield value\n    }\n  }\n}\n","import { Iterables } from '../types'\nimport { unwrap } from '../util'\n\n/**\n * @example\n * zip([1, 2, 3], [4, 5, 6]) // ([1 4] [2 5] [3 6])\n * zip([1, 2, 3], 'foobar') // ([1 f] [2 o] [3 o])\n */\nexport function* zip<T extends any[]>(...its: Iterables<T>) {\n  for (const itsʹ = its.map(unwrap); ;) {\n    const values = []\n    for (const it of itsʹ) {\n      const { done, value } = it.next()\n      if (done)\n        return\n      values.push(value)\n    }\n    yield values as T\n  }\n}\n","import { Methods } from './types'\n\nexport const done = <T>() =>\n  ({ done: true }) as IteratorResult<T>\n\nexport const value = <T>(value: T) =>\n  ({ value }) as IteratorResult<T>\n\nexport const wrap = <T>(it: Iterator<T>) =>\n  ({ [Symbol.iterator]: () => it }) as Iterable<T>\n\nexport const unwrap = <T>(it: Iterable<T>) =>\n  it[Symbol.iterator]()\n\nexport const lock = <T>(it: Iterable<T>) => {\n  const itʹ = unwrap(it)\n  return wrap({ next: itʹ.next.bind(itʹ) })\n}\n\nexport const staticMethods = <C>(ctor: C) => {\n  const props = Object.getOwnPropertyNames(ctor) as (keyof C)[]\n  const acc = {} as C\n  for (const prop of props)\n    if (typeof ctor[prop] === 'function')\n      acc[prop] = ctor[prop]\n  return acc as Methods<C>\n}\n","import { cast as castʹ } from '../uncurried/cast'\n\n/**\n * @example\n * cast(it => new Uint8Array(it))([1, 2, 3]) // Uint8Array\n * cast(it => new Set(it))([1, 2, 3]) // Set<number>\n * cast(it => new Set(it))('foobar') // Set<string>\n */\nexport const cast = <T, U>(fn: (it: Iterable<T>) => U) => (it: Iterable<T>) =>\n  castʹ(it, fn)\n","import { chunk as chunkʹ } from '../uncurried/chunk'\n\n/**\n * @example\n * chunk(2)([1, 2, 3, 4, 5]) // ([1 2] [3 4] [5])\n * chunk(3)('foobar') // ([f o o] [b a r])\n */\nexport const chunk = (size: number) => <T>(it: Iterable<T>) =>\n  chunkʹ(it, size)\n","import { count as countʹ } from '../uncurried/count'\n\n/**\n * @example\n * count()() // (0 1 2 3 4 …)\n * count()(5) // (5 6 7 8 9 …)\n * count(-1)(5) // (5 4 3 2 1 …)\n * count(-2)(0) // (0 -2 -4 -6 …)\n */\nexport const count = (start?: number) => (step?: number) =>\n  countʹ(start, step)\n","import { cycle as cycleʹ } from '../uncurried/cycle'\n\n/**\n * @example\n * cycle(2)([1, 2, 3]) // (1 2 3 1 2 3)\n * cycle()([1, 2, 3]) // (1 2 3 1 2 3 …)\n * cycle()('foo') // (f o o f o …)\n */\nexport const cycle = (times?: number) => <T>(it: Iterable<T>) =>\n  cycleʹ(it, times)\n","import { drop as dropʹ } from '../uncurried/drop'\n\n/**\n * @example\n * drop(2)([1, 2, 3, 4, 5]) // (3 4 5)\n * drop(3)('foobar') // (b a r)\n */\nexport const drop = (amount?: number) => <T>(it: Iterable<T>) =>\n  dropʹ(it, amount)\n","import { Callback } from '../types'\nimport { dropWhile as dropWhileʹ } from '../uncurried/dropWhile'\n\n/**\n * @example\n * dropWhile(n => n < 3)([1, 2, 3, 4, 5]) // (3 4 5)\n * dropWhile(c => c != 'b')('foobar') // (b a r)\n */\nexport const dropWhile = <T>(fn: Callback<T, boolean>) => (it: Iterable<T>) =>\n  dropWhileʹ(it, fn)\n","import { Callback } from '../types'\nimport { every as everyʹ } from '../uncurried/every'\n\n/**\n * @example\n * every(n => n > 0)([1, 2, 3]) // true\n * every(n => n > 1)([1, 2, 3]) // false\n */\nexport const every = <T>(fn: Callback<T, boolean>) => (it: Iterable<T>) =>\n  everyʹ(it, fn)\n","import { Callback } from '../types'\nimport { filter as filterʹ } from '../uncurried/filter'\n\n/**\n * @example\n * filter(n => n%2 == 0)([1, 2, 3, 4, 5]) // (2 4)\n * filter(n => n%2 != 0)([1, 2, 3, 4, 5]) // (1 3 5)\n * filter(c => c != 'o')('foobar') // (f b a r)\n */\nexport const filter = <T>(fn: Callback<T, boolean>) => (it: Iterable<T>) =>\n  filterʹ(it, fn)\n","import { Callback } from '../types'\nimport { find as findʹ } from '../uncurried/find'\n\n/**\n * @example\n * find(n => n%2 == 0)([1, 2, 3]) // 2\n * find(n => n%2 != 0)([1, 2, 3]) // 1\n * find(c => c != 'f')('foobar') // o\n */\nexport const find = <T>(fn: Callback<T, boolean>) => (it: Iterable<T>) =>\n  findʹ(it, fn)\n","import { Callback } from '../types'\nimport { flatMap as flatMapʹ } from '../uncurried/flatMap'\n\n/**\n * @example\n * flatMap(n => [-n, +n])([1, 2, 3]) // (-1 1 -2 2 -3 3)\n * flatMap(s => s)(['foo', 'bar']) // (f o o b a r)\n */\nexport const flatMap = <T, U>(fn: Callback<T, U[]>) => (it: Iterable<T>) =>\n  flatMapʹ(it, fn)\n","import { Callback } from '../types'\nimport { forEach as forEachʹ } from '../uncurried/forEach'\n\n/**\n * @example\n * forEach(n => log(n))([1, 2, 3, 4, 5])\n * forEach((c, i) => log(i, c))('foobar')\n */\nexport const forEach = <T>(fn: Callback<T, void>) => (it: Iterable<T>) =>\n  forEachʹ(it, fn)\n","import { generate as generateʹ } from '../uncurried/generate'\n\n/**\n * @example\n * generate(5)(Math.random) // 5 random numbers\n * generate(5)(i => i) // (0 1 2 3 4)\n * generate()(i => i) // (0 1 2 3 4 …)\n */\nexport const generate = (times?: number) => <T>(fn: (index: number) => T) =>\n  generateʹ(fn, times)\n","import { Callback } from '../types'\nimport { inspect as inspectʹ } from '../uncurried/inspect'\n\n/**\n * @example\n * inspect(n => log(n))([1, 2, 3, 4, 5]) // (1 2 3 4 5)\n * inspect((c, i) => log(i, c))('foobar') // (f o …)\n */\nexport const inspect = <T>(fn: Callback<T, void>) => (it: Iterable<T>) =>\n  inspectʹ(it, fn)\n","import { loop as loopʹ } from '../uncurried/loop'\n\n/**\n * @example\n * function* countTo3() { for (let i = 1; i <= 3; i++) yield i }\n * function* countTo(n) { for (let i = 1; i <= n; i++) yield i }\n * loop()(countTo3) // (1 2 3 1 2 3 1 2 3 …)\n * loop(3)(countTo3) // (1 2 3 1 2 3 1 2 3)\n * loop(4)(countTo) // (1 1 2 1 2 3 1 2 3 4)\n */\nexport const loop = (times?: number) => <T>(fn: (index: number) => Iterable<T>) =>\n  loopʹ(fn, times)\n","import { Callback } from '../types'\nimport { map as mapʹ } from '../uncurried/map'\n\n/**\n * @example\n * map(n => 2*n)([1, 2, 3, 4, 5]) // (2 4 6 8 10)\n * map(c => c.charCodeAt(0))('foo') // (102 111 111)\n */\nexport const map = <T, U>(fn: Callback<T, U>) => (it: Iterable<T>) =>\n  mapʹ(it, fn)\n","import { match as matchʹ } from '../uncurried/match'\n\n/**\n * @example\n * // ([foo f oo] [bar b ar] [baz b az])\n * match(/(f|b)(..)/g)('foobarbaz')\n */\nexport const match = (regexp: RegExp) => (input: string) =>\n  matchʹ(input, regexp)\n","import { nth as nthʹ } from '../uncurried/nth'\n\n/**\n * @example\n * nth(1)([1, 2, 3]) // 2\n * nth(0)('foobar') // f\n * nth(3)('foobar') // b\n */\nexport const nth = (n: number) => <T>(it: Iterable<T>) =>\n  nthʹ(it, n)\n","import { range as rangeʹ } from '../uncurried/range'\n\n/**\n * @example\n * range()()() // (0 1 2 3 4 …)\n * range(0)(5)() // (0 1 2 3 4)\n * range(1)(10)(2) // (1 3 5 7 9)\n */\nexport const range = (start?: number) => (stop?: number) => (step?: number) =>\n  rangeʹ(start, stop, step)\n","import { Reducer } from '../types'\nimport { reduce as reduceʹ } from '../uncurried/reduce'\n\n/**\n * @example\n * reduce((acc, n) => acc + n)(0)([1, 2, 3]) // 6\n * reduce((acc, n) => acc + n)('')([1, 2, 3]) // 123\n * reduce((map, c, i) => map.set(i, c))(new Map)('foo') // Map\n */\nexport const reduce = <T, U>(fn: Reducer<T, U>) => (first: U) => (it: Iterable<T>) =>\n  reduceʹ(it, fn, first)\n","import { repeat as repeatʹ } from '../uncurried/repeat'\n\n/**\n * @example\n * repeat()(42) // (42 42 42 …)\n * repeat(5)(42) // (42 42 42 42 42)\n * repeat(3)('foo') // (foo foo foo)\n */\nexport const repeat = (times?: number) => <T>(value: T) =>\n  repeatʹ(value, times)\n","import { Callback } from '../types'\nimport { sequence as sequenceʹ } from '../uncurried/sequence'\n\n/**\n * @example\n * sequence()(n => n+1)(1) // (1 2 3 4 5 …)\n * sequence(7)(n => n*2)(1) // (1 2 4 8 16 32 64)\n * sequence(5)(n => n**2)(2) // (2 4 16 256 65536)\n */\nexport const sequence = (length?: number) => <T>(fn: Callback<T, T>) => (first: T) =>\n  sequenceʹ(fn, first, length)\n","import { Callback } from '../types'\nimport { some as someʹ } from '../uncurried/some'\n\n/**\n * @example\n * some(n => n < 2)([1, 2, 3]) // true\n * some(n => n < 1)([1, 2, 3]) // false\n */\nexport const some = <T>(fn: Callback<T, boolean>) => (it: Iterable<T>) =>\n  someʹ(it, fn)\n","import { take as takeʹ } from '../uncurried/take'\n\n/**\n * @example\n * take(3)([1, 2, 3, 4, 5]) // (1 2 3)\n * take(3)('foobar') // (f o o)\n */\nexport const take = (amount?: number) => <T>(it: Iterable<T>) =>\n  takeʹ(it, amount)\n","import { Callback } from '../types'\nimport { takeWhile as takeWhileʹ } from '../uncurried/takeWhile'\n\n/**\n * @example\n * takeWhile(n => n < 4)([1, 2, 3, 4, 5]) // (1 2 3)\n * takeWhile(c => c != 'b')('foobar') // (f o o)\n */\nexport const takeWhile = <T>(fn: Callback<T, boolean>) => (it: Iterable<T>) =>\n  takeWhileʹ(it, fn)\n","import { Callback, Flatten, Reducer } from './types'\nimport { staticMethods } from './util'\nimport * as uc from './uncurried'\nimport * as c from './curried'\n\nexport class IT<T> implements Iterable<T> {\n  [Symbol.iterator]: () => Iterator<T>\n\n  static uncurried = uc\n  static curried = c\n\n  constructor(it: Iterable<T>) {\n    this[Symbol.iterator] = it[Symbol.iterator].bind(it)\n  }\n\n  /**\n   * @example\n   * it.count() // (0 1 2 3 4 …)\n   * it.count(5) // (5 6 7 8 9 …)\n   * it.count(5, -1) // (5 4 3 2 1 …)\n   * it.count(0, -2) // (0 -2 -4 -6 …)\n   */\n  static count(start?: number, step?: number) {\n    return it(uc.count(start, step))\n  }\n\n  /**\n   * @example\n   * it.generate(Math.random, 5) // 5 random numbers\n   * it.generate(i => i, 5) // (0 1 2 3 4)\n   * it.generate(i => i) // (0 1 2 3 4 …)\n   */\n  static generate<T>(fn: (index: number) => T, times?: number) {\n    return it(uc.generate(fn, times))\n  }\n\n  /**\n   * @example\n   * function* countTo3() { for (let i = 1; i <= 3; i++) yield i }\n   * function* countTo(n) { for (let i = 1; i <= n; i++) yield i }\n   * it.loop(countTo3) // (1 2 3 1 2 3 1 2 3 …)\n   * it.loop(countTo3, 3) // (1 2 3 1 2 3 1 2 3)\n   * it.loop(countTo, 4) // (1 1 2 1 2 3 1 2 3 4)\n   */\n  static loop<T>(fn: (index: number) => Iterable<T>, times?: number) {\n    return it(uc.loop(fn, times))\n  }\n\n  /**\n   * @example\n   * // ([foo f oo] [bar b ar] [baz b az])\n   * it.match('foobarbaz', /(f|b)(..)/g)\n   */\n  static match(input: string, regexp: RegExp) {\n    return it(uc.match(input, regexp))\n  }\n\n  /**\n   * @example\n   * it.range() // (0 1 2 3 4 …)\n   * it.range(0, 5) // (0 1 2 3 4)\n   * it.range(1, 10, 2) // (1 3 5 7 9)\n   */\n  static range(start?: number, stop?: number, step?: number) {\n    return it(uc.range(start, stop, step))\n  }\n\n  /**\n   * @example\n   * it.repeat(42) // (42 42 42 …)\n   * it.repeat(42, 5) // (42 42 42 42 42)\n   * it.repeat('foo', 3) // (foo foo foo)\n   */\n  static repeat<T>(value: T, times?: number) {\n    return it(uc.repeat(value, times))\n  }\n\n  /**\n   * @example\n   * it.sequence(n => n+1, 1) // (1 2 3 4 5 …)\n   * it.sequence(n => n*2, 1, 7) // (1 2 4 8 16 32 64)\n   * it.sequence(n => n**2, 2, 5) // (2 4 16 256 65536)\n   */\n  static sequence<T>(fn: Callback<T, T>, first: T, length?: number) {\n    return it(uc.sequence(fn, first, length))\n  }\n\n  /**\n   * @example\n   * it([1, 2, 3]).cast(it => new Uint8Array(it)) // Uint8Array\n   * it([1, 2, 3]).cast(it => new Set(it)) // Set<number>\n   * it('foobar').cast(it => new Set(it)) // Set<string>\n   */\n  cast<U>(fn: (it: this) => U) {\n    return uc.cast(this, fn as () => U)\n  }\n\n  /**\n   * @example\n   * it([1, 2, 3, 4, 5]).chunk(2) // ([1 2] [3 4] [5])\n   * it('foobar').chunk(3) // ([f o o] [b a r])\n   */\n  chunk(size: number) {\n    return it(uc.chunk(this, size))\n  }\n\n  /**\n   * @example\n   * it([1, 2]).chain([3, 4], [5]) // (1 2 3 4 5)\n   * it('foo').chain('bar') // (f o o b a r)\n   */\n  chain<U>(...its: Iterable<U>[]) {\n    return it(uc.chain<T | U>(this, ...its))\n  }\n\n  /**\n   * @example\n   * it([1, 2, 3, 4, 5]).collect() // [1 2 3 4 5]\n   * it('foobar').collect() // [f o o b a r]\n   */\n  collect() {\n    return uc.collect(this)\n  }\n\n  /**\n   * @example\n   * it([1, 2, 3]).cycle(2) // (1 2 3 1 2 3)\n   * it([1, 2, 3]).cycle() // (1 2 3 1 2 3 …)\n   * it('foo').cycle() // (f o o f o …)\n   */\n  cycle(times?: number) {\n    return it(uc.cycle(this, times))\n  }\n\n  /**\n   * @example\n   * it([1, 2, 3, 4, 5]).drop(2) // (3 4 5)\n   * it('foobar').drop(3) // (b a r)\n   */\n  drop(amount?: number) {\n    return it(uc.drop(this, amount))\n  }\n\n  /**\n   * @example\n   * it([1, 2, 3, 4, 5]).dropWhile(n => n < 3) // (3 4 5)\n   * it('foobar').dropWhile(c => c != 'b') // (b a r)\n   */\n  dropWhile(fn: Callback<T, boolean>) {\n    return it(uc.dropWhile(this, fn))\n  }\n\n  /**\n   * @example\n   * it(['foo', 'bar']).enumerate() // ([0 foo] [1 bar])\n   * it('foo').enumerate() // ([0 f] [1 o] [2 o])\n   */\n  enumerate() {\n    return it(uc.enumerate(this))\n  }\n\n  /**\n   * @example\n   * it([1, 2, 3]).every(n => n > 0) // true\n   * it([1, 2, 3]).every(n => n > 1) // false\n   */\n  every(fn: Callback<T, boolean>) {\n    return uc.every(this, fn)\n  }\n\n  /**\n   * @example\n   * it([1, 2, 3, 4, 5]).filter(n => n%2 == 0) // (2 4)\n   * it([1, 2, 3, 4, 5]).filter(n => n%2 != 0) // (1 3 5)\n   * it('foobar').filter(c => c != 'o') // (f b a r)\n   */\n  filter(fn: Callback<T, boolean>) {\n    return it(uc.filter(this, fn))\n  }\n\n  /**\n   * @example\n   * it([1, 2, 3]).find(n => n%2 == 0) // 2\n   * it([1, 2, 3]).find(n => n%2 != 0) // 1\n   * it('foobar').find(c => c != 'f') // o\n   */\n  find(fn: Callback<T, boolean>) {\n    return uc.find(this, fn)\n  }\n\n  /**\n   * @example\n   * it([1, 2, 3]).first() // 1\n   * it('foobar').first() // f\n   */\n  first() {\n    return uc.first(this)\n  }\n\n  /**\n   * @example\n   * it([1, 2, 3]).flatMap(n => [-n, +n]) // (-1 1 -2 2 -3 3)\n   * it(['foo', 'bar']).flatMap(s => s) // (f o o b a r)\n   */\n  flatMap<U>(fn: Callback<T, U[]>) {\n    return it(uc.flatMap(this, fn))\n  }\n\n  /**\n   * @example\n   * it([[1, 2], [3, 4], [5]]).flatten() // (1 2 3 4 5)\n   * it(['foo', 'bar']).flatten() // (f o o b a r)\n   */\n  flatten() {\n    return it(uc.flatten<Flatten<T>>(this as any))\n  }\n\n  /**\n   * @example\n   * it([1, 2, 3, 4, 5]).forEach(n => log(n))\n   * it('foobar').forEach((c, i) => log(i, c))\n   */\n  forEach(fn: Callback<T, void>) {\n    uc.forEach(this, fn)\n  }\n\n  /**\n   * @example\n   * it([1, 2, 3, 4, 5]).inspect(n => log(n)) // (1 2 3 4 5)\n   * it('foobar').inspect((c, i) => log(i, c)) // (f o …)\n   */\n  inspect(fn: Callback<T, void>) {\n    return it(uc.inspect(this, fn))\n  }\n\n  /**\n   * @example\n   * it([1, 2, 3]).last() // 3\n   * it('foobar').last() // r\n   */\n  last() {\n    return uc.last(this)\n  }\n\n  /**\n   * @example\n   * it([1, 2, 3]).length() // 3\n   * it('foobar').length() // 6\n   */\n  length() {\n    return uc.length(this)\n  }\n\n  /**\n   * @example\n   * it([1, 2, 3, 4, 5]).map(n => 2*n) // (2 4 6 8 10)\n   * it('foo').map(c => c.charCodeAt(0)) // (102 111 111)\n   */\n  map<U>(fn: Callback<T, U>) {\n    return it(uc.map(this, fn))\n  }\n\n  /**\n   * @example\n   * it([1, 2, 3]).nth(1) // 2\n   * it('foobar').nth(0) // f\n   * it('foobar').nth(3) // b\n   */\n  nth(n: number) {\n    return uc.nth(this, n)\n  }\n\n  /**\n   * @example\n   * it([1, 2, 3]).reduce((acc, n) => acc + n, 0) // 6\n   * it([1, 2, 3]).reduce((acc, n) => acc + n, '') // 123\n   * it('foo').reduce((map, c, i) => map.set(i, c), new Map) // Map\n   */\n  reduce<U>(fn: Reducer<T, U>, first: U) {\n    return uc.reduce(this, fn, first)\n  }\n\n  /**\n   * @example\n   * it([1, 2, 3]).some(n => n < 2) // true\n   * it([1, 2, 3]).some(n => n < 1) // false\n   */\n  some(fn: Callback<T, boolean>) {\n    return uc.some(this, fn)\n  }\n\n  /**\n   * @example\n   * it([1, 2, 3, 4, 5]).take(3) // (1 2 3)\n   * it('foobar').take(3) // (f o o)\n   */\n  take(amount?: number) {\n    return it(uc.take(this, amount))\n  }\n\n  /**\n   * @example\n   * it([1, 2, 3, 4, 5]).takeWhile(n => n < 4) // (1 2 3)\n   * it('foobar').takeWhile(c => c != 'b') // (f o o)\n   */\n  takeWhile(fn: Callback<T, boolean>) {\n    return it(uc.takeWhile(this, fn))\n  }\n\n  /**\n   * @example\n   * it('foobar').then(chars => new Set(chars)) // (f o b a r)\n   * it('foobar').then(chars => [...chars].sort()) // (a b f o o r)\n   * it('foobar').then(chars => [...chars].reverse()) // (r a b o o f)\n   */\n  then<U>(fn: (it: this) => Iterable<U>) {\n    return it(fn(this))\n  }\n\n  /**\n   * @example\n   * it([1, 3, 3, 7]).unique() // (1 3 7)\n   * it('foobar').unique() // (f o b a r)\n   */\n  unique() {\n    return it(uc.unique(this))\n  }\n\n  /**\n   * @example\n   * it([1, 2, 3]).zip([4, 5, 6]) // ([1 4] [2 5] [3 6])\n   * it([1, 2, 3]).zip('foobar') // ([1 f] [2 o] [3 o])\n   */\n  zip<U>(itʹ: Iterable<U>) {\n    return it(uc.zip(this, itʹ))\n  }\n}\n\nexport const it = Object.assign(\n  <T>(it: Iterable<T>) => new IT(it),\n  staticMethods(IT)\n)\n"],"names":["cast","it","fn","chain","its","chunk","size","value","push","splice","length","count","start","step","n","collect","cycle","times","Infinity","i","drop","amount","itʹ","lock","dropWhile","enumerate","every","filter","find","first","flatMap","flatten","forEach","generate","inspect","last","_","loop","map","match","input","regexp","exec","nth","range","stop","reduce","acc","repeat","sequence","some","take","takeWhile","unique","set","Set","has","add","zip","itsʹ","unwrap","values","done","next","Symbol","iterator","[object Object]","wrap","bind","castʹ","chunkʹ","countʹ","cycleʹ","dropʹ","dropWhileʹ","everyʹ","filterʹ","findʹ","flatMapʹ","forEachʹ","generateʹ","inspectʹ","loopʹ","mapʹ","matchʹ","nthʹ","rangeʹ","reduceʹ","repeatʹ","sequenceʹ","someʹ","takeʹ","takeWhileʹ","IT","this","uc.count","uc.generate","uc.loop","uc.match","uc.range","uc.repeat","uc.sequence","uc.cast","uc.chunk","uc.chain","uc.collect","uc.cycle","uc.drop","uc.dropWhile","uc.enumerate","uc.every","uc.filter","uc.find","uc.first","uc.flatMap","uc.flatten","uc.forEach","uc.inspect","uc.last","uc.length","uc.map","uc.nth","uc.reduce","uc.some","uc.take","uc.takeWhile","uc.unique","uc.zip","uc","c","Object","assign","ctor","props","getOwnPropertyNames","prop","staticMethods"],"mappings":"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"}