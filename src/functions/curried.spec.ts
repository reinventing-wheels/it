import * as c from './curried'

export function* countTo(n: number) { for (let i = 1; i <= n;) yield i++ }
export function* leet() { yield* [1, 3, 3, 7] }

export const add = (n: number, m: number) => n + m
export const double = (n: number) => 2*n
export const isOdd = (n: number) => n%2 !== 0

describe('functions', () => {
  describe('forEach', () => {
    it('should call a function for each value of an iterable', () => {
      const fn = jest.fn()
      c.forEach(fn)(countTo(5))
      expect(fn.mock.calls).toEqual([[1, 0], [2, 1], [3, 2], [4, 3], [5, 4]])
    })
  })

  describe('reduce', () => {
    it('should reduce an iterable to a single value', () => {
      const expected = 15
      const received = c.reduce(add)(0)(countTo(5))
      expect(received).toEqual(expected)
    })
  })

  describe('filter', () => {
    it('should filter values of an iterable', () => {
      const expected = [1, 3, 5]
      const received = [...c.filter(isOdd)(countTo(5))]
      expect(received).toEqual(expected)
    })
  })

  describe('map', () => {
    it('should map values of an iterable', () => {
      const expected = [2, 4, 6, 8, 10]
      const received = [...c.map(double)(countTo(5))]
      expect(received).toEqual(expected)
    })
  })

  describe('concat', () => {
    it('should concatenate multiple iterables to a single one', () => {
      const expected = [...'foo', ...'bar', ...'baz']
      const received = [...c.concat('foo', 'bar', 'baz')]
      expect(received).toEqual(expected)
    })
  })

  describe('flatten', () => {
    it('should flatten an iterable', () => {
      const expected = [1, [2], 3, 4, [5], 6]
      const received = [...c.flatten([[1, [2], 3], [4, [5], 6]])]
      expect(received).toEqual(expected)
    })
  })

  describe('cycle', () => {
    it('should yield values from an iterable in cycle', () => {
      const expected = [...'foofoofoof']
      const received = [...c.take(10)(c.cycle('foo'))]
      expect(received).toEqual(expected)
    })
  })

  describe('repeat', () => {
    it('should repeatedly yield the same value', () => {
      const expected = [42, 42, 42, 42, 42]
      const received = [...c.take(5)(c.repeat(42))]
      expect(received).toEqual(expected)
    })
  })

  describe('loop', () => {
    it('should loop a generator function', () => {
      const expected = [...leet(), ...leet(), ...leet()]
      const received = [...c.take(12)(c.loop(leet))]
      expect(received).toEqual(expected)
    })
  })

  describe('generate', () => {
    it('should yield values generated by a function', () => {
      const expected = [0, 2, 4, 6, 8]
      const received = [...c.take(5)(c.generate(double))]
      expect(received).toEqual(expected)
    })
  })

  describe('sequence', () => {
    it('should yield a sequence of values derived from previous values', () => {
      const expected = [1, 2, 4, 8, 16]
      const received = [...c.take(5)(c.sequence(double)(1))]
      expect(received).toEqual(expected)
    })
  })

  describe('range', () => {
    it('should yield a sequence of monotonically increasing values', () => {
      const expected = [0, 1, 2, 3, 4]
      const received = [...c.take(5)(c.range()()())]
      expect(received).toEqual(expected)
    })
  })

  describe('match', () => {
    it('should yield a sequence of matches', () => {
      const expected = [['foo', 'f'], ['bar', 'b'], ['baz', 'b']]
      const received = [...c.match(/(\S)\S*/g)('foo bar baz')].map(m => [...m])
      expect(received).toMatchObject(expected)
    })
  })

  describe('chunk', () => {
    it('should yield an iterable by chunks of specified size', () => {
      const expected = [[1, 2], [3, 4], [5]]
      const received = [...c.chunk(2)(countTo(5))]
      expect(received).toEqual(expected)
    })
  })

  describe('zip', () => {
    it('should zip multiple iterables to a single one', () => {
      const expected = [['f', 'b'], ['o', 'a'], ['o', 'r']]
      const received = [...c.zip('foo', 'bar')]
      expect(received).toEqual(expected)
    })
  })

  describe('take', () => {
    it('should take specified amount of values from an iterable', () => {
      const expected = [1, 2, 3]
      const received = [...c.take(3)(countTo(5))]
      expect(received).toEqual(expected)
    })
  })

  describe('drop', () => {
    it('should drop specified amount of values from an iterable', () => {
      const expected = [3, 4, 5]
      const received = [...c.drop(2)(countTo(5))]
      expect(received).toEqual(expected)
    })
  })
})
