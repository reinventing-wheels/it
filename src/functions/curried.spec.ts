import { forEach, reduce, filter, map, concat, repeat, take, drop } from './curried'
import { always, loop, generate, sequence, range, match } from './curried'

describe('functions', () => {
  const countTo5 = () => range(1)(6)()

  describe('forEach', () => {
    it('should call a function for each value of an iterable', () => {
      const fn = jest.fn()
      forEach(fn)(countTo5())
      expect(fn.mock.calls).toEqual([[1, 0], [2, 1], [3, 2], [4, 3], [5, 4]])
    })
  })

  describe('reduce', () => {
    it('should reduce an iterable to a single value', () => {
      const expected = 15
      const received = reduce((a: number, b: number) => a + b)(0)(countTo5())
      expect(received).toEqual(expected)
    })
  })

  describe('filter', () => {
    it('should filter values of an iterable', () => {
      const expected = [1, 3, 5]
      const received = [...filter((n: number) => n%2 !== 0)(countTo5())]
      expect(received).toEqual(expected)
    })
  })

  describe('map', () => {
    it('should map values of an iterable', () => {
      const expected = [2, 3, 4, 5, 6]
      const received = [...map((n: number) => n + 1)(countTo5())]
      expect(received).toEqual(expected)
    })
  })

  describe('concat', () => {
    it('should concatenate multiple iterables to a single one', () => {
      const expected = [...'foo', ...'bar', ...'baz']
      const received = [...concat('foo', 'bar', 'baz')]
      expect(received).toEqual(expected)
    })
  })

  describe('repeat', () => {
    it('should repeatedly yield values from the same iterable', () => {
      const expected = [...'foofoofoof']
      const received = [...take(10)(repeat('foo'))]
      expect(received).toEqual(expected)
    })
  })

  describe('always', () => {
    it('should always yield the same value', () => {
      const expected = [42, 42, 42, 42, 42]
      const received = [...take(5)(always(42))]
      expect(received).toEqual(expected)
    })
  })

  describe('loop', () => {
    it('should loop a generator function', () => {
      const expected = [...countTo5(), ...countTo5(), ...countTo5()]
      const received = [...take(15)(loop(countTo5))]
      expect(received).toEqual(expected)
    })
  })

  describe('generate', () => {
    it('should yield values generated by a function', () => {
      const expected = [0, 1, 2, 3, 4]
      const received = [...take(5)(generate(i => i))]
      expect(received).toEqual(expected)
    })
  })

  describe('sequence', () => {
    it('should yield a sequence of values derived from previous values', () => {
      const expected = [1, 2, 4, 8, 16]
      const received = [...take(5)(sequence((n: number) => n*2)(1))]
      expect(received).toEqual(expected)
    })
  })

  describe('range', () => {
    it('should yield a sequence of monotonically increasing values', () => {
      const expected = [0, 1, 2, 3, 4]
      const received = [...take(5)(range()()())]
      expect(received).toEqual(expected)
    })
  })

  describe('match', () => {
    it('should yield a sequence of matches', () => {
      const expected = [['foo', 'f'], ['bar', 'b'], ['baz', 'b']]
      const received = [...match(/(\S)\S*/g)('foo bar baz')].map(m => [...m])
      expect(received).toMatchObject(expected)
    })
  })

  describe('take', () => {
    it('should take some amount values from an iterable', () => {
      const expected = [1, 2, 3]
      const received = [...take(3)(countTo5())]
      expect(received).toEqual(expected)
    })
  })

  describe('drop', () => {
    it('should drop some amount values from an iterable', () => {
      const expected = [3, 4, 5]
      const received = [...drop(2)(countTo5())]
      expect(received).toEqual(expected)
    })
  })
})
