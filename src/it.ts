import { Callback, Reducer } from './types'
import { forEach, reduce, filter, map, concat, cycle, zip, take, drop } from './functions/uncurried'
import { repeat, loop, generate, sequence, range, match } from './functions/uncurried'
import * as uncurried from './functions/uncurried'
import * as curried from './functions/curried'

export const it = <T>(it: Iterable<T>) => new It(it)

export class It<T> implements Iterable<T> {
  [Symbol.iterator]: () => Iterator<T>

  static uncurried = uncurried
  static curried = curried

  /** Repeatedly yields the same value. */
  static repeat<T>(value: T) {
    return new It(repeat(value))
  }

  /** Loops a generator function. */
  static loop<T>(fn: (index: number) => Iterable<T>) {
    return new It(loop(fn))
  }

  /** Yields values generated by a function. */
  static generate<T>(fn: (index: number) => T) {
    return new It(generate(fn))
  }

  /** Yields a sequence of values derived from previous values. */
  static sequence<T>(fn: Callback<T, T>, first: T) {
    return new It(sequence(fn, first))
  }

  /** Yields a sequence of monotonically increasing numbers. */
  static range(start?: number, stop?: number, step?: number) {
    return new It(range(start, stop, step))
  }

  /** Yields a sequence of matches. */
  static match(input: string, regexp: RegExp) {
    return new It(match(input, regexp))
  }

  constructor(it: Iterable<T>) {
    this[Symbol.iterator] = it[Symbol.iterator].bind(it)
  }

  /** Casts the iterable to other data structure. */
  cast<T>(fn: (it: this) => T) {
    return fn(this)
  }

  /** Calls a function for each value of the iterable. */
  forEach(fn: Callback<T, void>) {
    forEach(this, fn)
  }

  /** Reduces the iterable to a single value. */
  reduce<U>(fn: Reducer<T, U>, first: U) {
    return reduce(this, fn, first)
  }

  /** Filters values of the iterable. */
  filter(fn: Callback<T, boolean>) {
    return new It(filter(this, fn))
  }

  /** Maps values of the iterable. */
  map<U>(fn: Callback<T, U>) {
    return new It(map(this, fn))
  }

  /** Concatenates multiple iterables to a single one. */
  concat<U>(...its: Iterable<U>[]) {
    return new It(concat<T | U>(this, ...its))
  }

  /** Yields values from the iterable in cycle. */
  cycle() {
    return new It(cycle(this))
  }

  /** Zips multiple iterables to a single one. */
  zip<U>(...its: Iterable<U>[]) {
    return new It(zip<T | U>(this, ...its))
  }

  /** Takes some amount of values from the iterable. */
  take(amount: number) {
    return new It(take(this, amount))
  }

  /** Drops some amount of values from the iterable. */
  drop(amount: number) {
    return new It(drop(this, amount))
  }
}
