import { Callback, Reducer } from './types'
import * as uc from './functions/uncurried'
import * as c from './functions/curried'

export const it = <T>(it: Iterable<T>) => new It(it)

export class It<T> implements Iterable<T> {
  [Symbol.iterator]: () => Iterator<T>

  static uncurried = uc
  static curried = c

  constructor(it: Iterable<T>) {
    this[Symbol.iterator] = it[Symbol.iterator].bind(it)
  }

  /** Repeatedly yields the same value. */
  static repeat<T>(value: T) {
    return new It(uc.repeat(value))
  }

  /** Loops a generator function. */
  static loop<T>(fn: (index: number) => Iterable<T>) {
    return new It(uc.loop(fn))
  }

  /** Yields values generated by a function. */
  static generate<T>(fn: (index: number) => T) {
    return new It(uc.generate(fn))
  }

  /** Yields a sequence of values derived from previous values. */
  static sequence<T>(fn: Callback<T, T>, first: T) {
    return new It(uc.sequence(fn, first))
  }

  /** Yields a sequence of monotonically increasing numbers. */
  static range(start?: number, stop?: number, step?: number) {
    return new It(uc.range(start, stop, step))
  }

  /** Yields a sequence of matches. */
  static match(input: string, regexp: RegExp) {
    return new It(uc.match(input, regexp))
  }

  /** Casts the iterable to other data structure. */
  cast<T>(fn: (it: this) => T) {
    return fn(this)
  }

  /** Calls a function for each value of the iterable. */
  forEach(fn: Callback<T, void>) {
    uc.forEach(this, fn)
  }

  /** Reduces the iterable to a single value. */
  reduce<U>(fn: Reducer<T, U>, first: U) {
    return uc.reduce(this, fn, first)
  }

  /** Filters values of the iterable. */
  filter(fn: Callback<T, boolean>) {
    return new It(uc.filter(this, fn))
  }

  /** Maps values of the iterable. */
  map<U>(fn: Callback<T, U>) {
    return new It(uc.map(this, fn))
  }

  /** Concatenates multiple iterables to a single one. */
  concat<U>(...its: Iterable<U>[]) {
    return new It(uc.concat<T | U>(this, ...its))
  }

  /** Yields values from the iterable in cycle. */
  cycle() {
    return new It(uc.cycle(this))
  }

  /** Yields the iterable by chunks of specified size. */
  chunk(size: number) {
    return new It(uc.chunk(this, size))
  }

  /** Zips multiple iterables to a single one. */
  zip<U>(...its: Iterable<U>[]) {
    return new It(uc.zip<T | U>(this, ...its))
  }

  /** Takes specified amount of values from the iterable. */
  take(amount: number) {
    return new It(uc.take(this, amount))
  }

  /** Drops specified amount of values from the iterable. */
  drop(amount: number) {
    return new It(uc.drop(this, amount))
  }
}
